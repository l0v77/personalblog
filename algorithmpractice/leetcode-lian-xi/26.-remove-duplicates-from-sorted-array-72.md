---
description: Tree Depth-First Search Binary Search Tree Binary Tree
---

# 501. Find Mode in Binary Search Tree

[题目链接](https://leetcode.com/problems/find-mode-in-binary-search-tree/description/)

## 解题思路(暴力)

````java
```java
class Solution {
    private Map<Integer, Integer> map;
    public int[] findMode(TreeNode root) {
        // 暴力解法，也适用于普通二叉树
        // 遍历过程中将数以及出现频率装进map
        // 遍历map for(Map.Entry<Integer, Integer> entry:map.entrySet())
        // 取出最高频次的几个
        // list.stream().mapToInt(i -> i).toArray();
        map = new HashMap<>();
        if (root == null) {
            return new int[]{0};
        }
        helper(root);
        int preCount = 0;
        List<Integer> tmp = new ArrayList<>();
        for (Map.Entry<Integer, Integer> entry: map.entrySet()) {
            if (preCount < entry.getValue()) {
                tmp.clear();
                tmp.add(entry.getKey());
                preCount = entry.getValue();
            } else if (preCount == entry.getValue()) {
                tmp.add(entry.getKey());
                
            }

        }
        return tmp.stream().mapToInt(Integer::intValue).toArray();
    }
    private void helper(TreeNode cur) {
        if (cur == null) return;
        map.put(cur.val, map.getOrDefault(cur.val, 0) + 1);
        helper(cur.left);
        helper(cur.right);
    }
}
```
````

## 时空复杂度

时间复杂度O(n)

空间复杂度O(logn + n)

## 解题思路

````java
```java
class Solution {
    TreeNode pre;
    int max;
    int now;
    List<Integer> resultList;
    public int[] findMode(TreeNode root) {
        // 因为是bst所以有不需要map的做法
        // 记录一个prenoder和当前node作对比，相同则当前count++
        // 之后和maximum作对比，如果大于maximum，清空list
        // 更新maximum
        // 当value变换的时候以及拿到第一个node时更新count为1
        if (root == null) {
            return new int[]{0};
        }
        resultList = new LinkedList<>();
        helper(root);
        return resultList.stream().mapToInt(i -> i).toArray();
    }
    private void helper(TreeNode cur) {
        if (cur == null) return;
        helper(cur.left);
        if (pre == null || pre.val != cur.val) {
            now = 1;
        } else if (pre.val == cur.val) {
            now++;
        }
        if (now > max) {
            resultList.clear();
            resultList.add(cur.val);
            max = now;
        } else if (now == max) {
            resultList.add(cur.val);
        }
        pre = cur;
        helper(cur.right);
    }
}
```
````

## 时空复杂度

时间复杂度O(n)

空间复杂度O(n+logn): 省去了map

