---
description: Array Backtracking
---

# 46. Permutations

[题目链接](https://leetcode.com/problems/permutations/description/)

## 解题思路

````java
```java
class Solution {
    List<List<Integer>> result;
    List<Integer> path;
    Set<Integer> set;

    public List<List<Integer>> permute(int[] nums) {
        // 暴力解法，树枝去重，用set或者list.contains都可以
        // 同支不可以复用
        result = new ArrayList<>();
        if (nums == null) return result;
        path = new ArrayList<>();
        set = new HashSet();
        helper(nums);
        return result;
    }
    private void helper(int[] nums) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if (set.contains(nums[i])) continue;
            path.add(nums[i]);
            set.add(nums[i]);
            helper(nums);
            set.remove(nums[i]);
            path.remove(path.size() - 1);
        }
    }
}
```
````

## 时空复杂度

时间复杂度O(n^n)

空间复杂度O(n)

